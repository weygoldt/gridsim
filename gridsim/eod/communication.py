#!/usr/bin/env python3

"""
Simulate frequency traces of chirps and rises.
Most of the code is just slightly modified from the original code by
Jan Benda et al. in the thunderfish package. The original code can be found
here: https://github.com/janscience/thunderfish
"""

from dataclasses import dataclass, field
from typing import List

import matplotlib.pyplot as plt
import numpy as np


@dataclass
class ChirpParams:
    """
    All parameters for simulating the frequency trace of chirps.
    """

    eodf: float = 500.0
    samplerate: float = 44100.0
    duration: float = 0.2
    chirp_times: List[float] = field(default_factory=lambda: np.array([0.1]))
    chirp_size: List[float] = field(default_factory=lambda: np.array([100.0]))
    chirp_width: List[float] = field(default_factory=lambda: np.array([0.01]))
    chirp_undershoot: List[float] = field(default_factory=lambda: np.array([0.1]))
    chirp_kurtosis: List[float] = field(default_factory=lambda: np.array([1.0]))
    chirp_contrasts: List[float] = field(default_factory=lambda: np.array([0.05]))


@dataclass
class RiseParams:
    """
    All parameters for simulating the frequency trace of rises.
    """

    eodf: float = 500
    samplerate: float = 44100.0
    duration: float = 5.0
    rise_times: List[float] = field(default_factory=lambda: np.array([0.5]))
    rise_size: List[float] = field(default_factory=lambda: np.array([80.0]))
    rise_tau: List[float] = field(default_factory=lambda: np.array([0.01]))
    decay_tau: List[float] = field(default_factory=lambda: np.array([0.1]))


def gaussian(chirp_t: np.ndarray, mu: float, width: float, kurt: float) -> np.ndarray:
    """
    Compute a Gaussian curve with the specified parameters.

    Parameters
    ----------
    chirp_t : numpy.ndarray
        The x-values of the curve.
    mu : float
        The mean of the Gaussian curve.
    width : float
        The standard deviation of the Gaussian curve.
    kurt : float
        The kurtosis of the Gaussian curve. A kurtosis of 1 corresponds to a
        Gaussian distribution.

    Returns
    -------
    numpy.ndarray
        The values of the Gaussian curve evaluated at the given x-values.
    """
    chirp_sig = 0.5 * width / (2.0 * np.log(10.0)) ** (0.5 / kurt)
    curve = np.exp(-0.5 * (((chirp_t - mu) / chirp_sig) ** 2.0) ** kurt)
    return curve


def chirps(params: ChirpParams) -> tuple[np.ndarray, np.ndarray]:
    """Simulate frequency trace with chirps.

    A chirp is modeled as a combination of two Gaussians. The first Gaussian is
    centered at the chirp time and has a width of chirp_width. The second Gaussian
    is centered at chirp_time + chirp_width / 2 and has the same width but a
    smaller amlitude determined by chirp_undershoot, which is a factor that
    is multiplied with the amplitude of the first Gaussian.

    Parameters
    ----------
    params : ChirpParams
        Parameters for simulating the frequency trace with chirps.

    Returns
    -------
    frequency : np.ndarray
        Generated frequency trace that can be passed on to wavefish_eods().
    amplitude : np.ndarray
        Generated amplitude modulation that can be used to multiply the trace
        generated by wavefish_eods().
    """
    n = int(params.duration * params.samplerate)
    frequency = params.eodf * np.ones(n)
    amplitude = np.ones(n)

    for time, width, undershoot, size, kurtosis, contrast in zip(
        params.chirp_times,
        params.chirp_width,
        params.chirp_undershoot,
        params.chirp_size,
        params.chirp_kurtosis,
        params.chirp_contrasts,
    ):
        chirp_t = np.arange(-3.0 * width, 3.0 * width, 1.0 / params.samplerate)
        g1 = gaussian(chirp_t, mu=0, width=width, kurt=kurtosis)
        g2 = gaussian(chirp_t, mu=width / 2, width=width, kurt=1)
        gauss = g1 * size - g2 * size * undershoot

        index = int(time * params.samplerate)
        i0 = index - len(gauss) // 2
        i1 = i0 + len(gauss)
        gi0 = 0
        gi1 = len(gauss)
        if i0 < 0:
            gi0 -= i0
            i0 = 0
        if i1 >= len(frequency):
            gi1 -= i1 - len(frequency)
            i1 = len(frequency)
        frequency[i0:i1] += gauss[gi0:gi1]
        amplitude[i0:i1] -= contrast * gauss[gi0:gi1] / size

    return frequency, amplitude


def rises(params: RiseParams) -> np.ndarray:
    """
    Simulate frequency trace with rises.

    A rise is modeled as a double exponential frequency modulation.

    Parameters
    ----------
    params : RisesParams
        A dataclass containing the parameters for simulating the frequency trace
        with rises.

    Returns
    -------
    numpy.ndarray
        Generate frequency trace that can be passed on to wavefish_eods().
    """

    n = int(params.duration * params.samplerate)

    # baseline eod frequency:
    frequency = params.eodf * np.ones(n)

    for time, size, riset, decayt in zip(
        params.rise_times, params.rise_size, params.rise_tau, params.decay_tau
    ):
        # rise frequency waveform:
        rise_t = np.arange(0.0, 10.0 * decayt, 1.0 / params.samplerate)
        rise = size * (1.0 - np.exp(-rise_t / riset)) * np.exp(-rise_t / decayt)

        # add rises on baseline eodf:
        index = int(time * params.samplerate)
        if index + len(rise) > len(frequency):
            rise_index = len(frequency) - index
            frequency[index : index + rise_index] += rise[:rise_index]
            break
        else:
            frequency[index : index + len(rise)] += rise
    return frequency


def main():
    cp = ChirpParams()
    rp = RiseParams()
    cf, ca = chirps(cp)
    rf = rises(rp)

    _, (ax1, ax2, ax3) = plt.subplots(3, 1)
    ax1.plot(cf)
    ax2.plot(ca)
    ax3.plot(rf)
    plt.show()

    pass


if __name__ == "__main__":
    main()
